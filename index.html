<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>è›‡å¹´æŠ½ç­¾æ”¶ç¥ç¦-byé™ˆç¡•è€å¸ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* ============ é¡µé¢æ•´ä½“é£æ ¼ ============ */
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #ffeef4 30%, #ffdff0 100%);
      font-family: 'Comic Sans MS', 'å¹¼åœ†', cursive;
      overflow-x: hidden;
      overflow-y: auto;
      position: relative;
      min-height: 100vh;
    }

    /* é¡¶éƒ¨æ ‡é¢˜ */
    h1 {
      text-align: center;
      color: #ff6699;
      margin: 16px 0 0;
      font-size: 1.8rem;
      text-shadow: 1px 1px #fff;
      position: relative;
    }
    h1 img {
      width: 40px;
      vertical-align: middle;
      margin-right: 6px;
    }
    .subtitle {
      text-align: center;
      color: #777;
      font-size: 0.9rem;
      margin: 4px auto 12px;
    }

    /* ============ æ•´ä½“å®¹å™¨ ============ */
    .container {
      width: 100%;
      max-width: 420px;
      margin: 0 auto 30px;
      border: 2px solid #ff6699;
      border-radius: 12px;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 2px 8px rgba(255, 100, 150, 0.2);
      overflow: hidden;
      position: relative;
      padding: 10px 0 20px;
    }

    /* ============ SVGä¸»åŒºåŸŸ ============ */
    .amidakuji-area {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    svg {
      background: #ffeeef;
      border: 2px dashed #ff6699;
      border-radius: 8px;
      width: 100%;
      max-width: 400px;
      height: 600px;
      position: relative;
    }

    /* è›‡å½¢ç«–çº¿ã€æ³¢æµªæ¨ªçº¿çš„å¤–è§‚ */
    .snake-line {
      fill: none;
      stroke: #ff66aa;
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.9;
    }
    .bridge-line {
      fill: none;
      stroke: #ffaa44;
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.9;
    }

    /* é¡¶éƒ¨å¯ç‚¹å‡»åœ†ç‚¹ */
    .top-circle {
      fill: #ff88cc;
      stroke: #fff;
      stroke-width: 2;
      cursor: pointer;
      transition: fill 0.2s;
    }
    .top-circle:hover {
      fill: #ffb3d9; /* ä»…æ”¹å˜é¢œè‰²ï¼Œä¸ç¼©æ”¾ */
    }

    /* å°çƒ */
    #movingCircle {
      fill: #ff8844;
      stroke: #fff;
      stroke-width: 2;
      display: none;
      filter: drop-shadow(0 0 6px rgba(255,150,0,0.6));
    }

    /* ============ åº•éƒ¨é—®å·å›¾æ ‡ ============ */
    .bottom-labels {
      margin-top: 10px;
      display: flex;
      justify-content: space-around;
      align-items: center;
    }
    .bottom-labels img {
      width: 38px;
      height: 38px;
    }

    /* ============ å¤§å¼¹çª— - æ˜¾ç¤ºç¥ç¦ ============ */
    .final-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.7);
      background: rgba(255, 255, 255, 0.95);
      border: 3px solid #ff6699;
      border-radius: 10px;
      padding: 20px;
      width: 80%;
      max-width: 320px;
      text-align: center;
      box-shadow: 0 0 10px rgba(255, 100, 150, 0.3);
      transition: transform 0.4s ease, opacity 0.4s ease;
      z-index: 9999;
      opacity: 0;
    }
    .final-popup.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
    .final-icon {
      font-size: 2rem;
      margin-bottom: 8px;
    }
    .final-blessing {
      color: #ff6699;
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 10px;
      white-space: nowrap;
    }
    .close-btn {
      border: none;
      background: #ff6699;
      color: #fff;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 0 3px rgba(255,100,150,0.2);
    }
    .close-btn:hover {
      background: #ff3377;
    }
  </style>
</head>
<body>
  <h1>
    <img src="snake.png" alt="snake" />
    è›‡å¹´æŠ½ç¥ç¦-byé™ˆç¡•è€å¸ˆ
  </h1>
  <div class="subtitle">ç‚¹å‡»é¡¶éƒ¨åœ†ç‚¹ï¼Œæ²¿è›‡å½¢ç«–æ†ç©¿æ¢­ï¼Œçœ‹çœ‹èƒ½æŠ½åˆ°å•¥æƒŠå–œï¼Ÿ</div>

  <div class="container">
    <div class="amidakuji-area">
      <svg id="amidakujiSvg" viewBox="0 0 400 600" preserveAspectRatio="xMidYMid meet">
        <circle id="movingCircle" r="8" cx="0" cy="0" />
      </svg>
    </div>
  </div>

  <!-- åº•éƒ¨ä½¿ç”¨é—®å·å›¾æ ‡ -->
  <div class="container" style="padding:5px 0 15px 0;">
    <div class="bottom-labels" id="bottomLabels"></div>
  </div>

  <!-- æœ€ç»ˆç¥ç¦å¼¹çª— -->
  <div class="final-popup" id="finalPopup">
    <div class="final-icon" id="finalIcon"></div>
    <div class="final-blessing" id="finalBlessing"></div>
    <button class="close-btn" id="closePopup">æ”¶åˆ°å•¦^_^</button>
  </div>

  <script>
    /**************************************************************
     * 1. æ•°æ®å‡†å¤‡ & å‚æ•°
     **************************************************************/
    const columns = 7;
    const width = 400, height = 600;
    const topY = 70, bottomY = 530; // åœ¨SVGé‡Œä¸Šä¸‹è¾¹ç•Œ

    // æ¯åˆ—éšæœºç»‘å®šçš„ç¥ç¦(å«å›¾æ ‡)
    const blessings = [
      { text: "æ•°å­¦å…¨æ»¡åˆ†", icon: "ğŸ“š" },
      { text: "è¶Šæ¥è¶Šèªæ˜", icon: "ğŸ“" },
      { text: "æ‰“è´¥éš¾é¢˜å¤§é­”ç‹", icon: "ğŸ‘¾" },
      { text: "èº«ä½“å£®å£®ä¸ç”Ÿç—…", icon: "ğŸ’ª" },
      { text: "å¤©å¤©ç¬‘å®¹ç¿çƒ‚", icon: "ğŸ˜Š" },
      { text: "çœ‹é€ä¸€åˆ‡çŸ¥è¯†çš„æœ¬è´¨", icon: "ğŸ”" },
      { text: "æ–°å¹´å¿«ä¹ã€çº¢åŒ…å¤šå¤š", icon: "ğŸ§¨" },
      { text: "å­¦ä¹ è¿›æ­¥ã€å¥åº·æˆé•¿", icon: "ğŸŒ±" },
      { text: "å¹¸è¿å¸¸ä¼´ä½ å·¦å³", icon: "ğŸŒˆ" },
      { text: "è®°å¿†è¶…ç¾¤ã€è¿‡ç›®ä¸å¿˜", icon: "âœ¨" },
    ];
    let temp = [...blessings];
    const finalColumnBlessings = [];
    for(let i=0; i<columns; i++){
      const idx = Math.floor(Math.random()*temp.length);
      finalColumnBlessings.push(temp[idx]);
      temp.splice(idx,1);
    }

    // ç”Ÿæˆ 7 åˆ—çš„è›‡å½¢å‡½æ•°
    const colSpacing = (width - 80)/(columns - 1);
    const colXs = [];
    for (let i=0; i<columns; i++){
      colXs.push(40 + i*colSpacing);
    }

    let snakeFuncs = [];
    let svg = document.getElementById("amidakujiSvg");

    /**************************************************************
     * 2. ç”Ÿæˆè›‡å½¢ç«–çº¿ + é¡¶éƒ¨åœ†ç‚¹
     **************************************************************/
    for (let i=0; i<columns; i++){
      const fn = createSnakeFunction(colXs[i], topY, bottomY);
      snakeFuncs.push(fn);

      // ç»˜åˆ¶ç«–çº¿(è›‡å½¢)
      const pathData = generatePathData(fn, 0, 1, 40);
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg","path");
      pathElem.setAttribute("d", pathData);
      pathElem.setAttribute("class", "snake-line");
      svg.appendChild(pathElem);

      // é¡¶éƒ¨å¯ç‚¹å‡»åœ†ç‚¹
      const ptTop = fn(0);
      const topCircle = document.createElementNS("http://www.w3.org/2000/svg","circle");
      topCircle.setAttribute("cx", ptTop.x);
      topCircle.setAttribute("cy", ptTop.y - 20);
      topCircle.setAttribute("r", 10);
      topCircle.setAttribute("class", "top-circle");
      topCircle.dataset.colIndex = i;
      topCircle.addEventListener("click", onTopCircleClick);
      svg.appendChild(topCircle);
    }

    /**************************************************************
     * 3. éšæœºç”Ÿæˆæ¨ªæ¢ + æœ€å°ç«–ç›´é—´éš”
     **************************************************************/
    let rawLines = [];
    // å…ˆéšæœºå‡ºè‹¥å¹²å€™é€‰(80~120)
    let M = 80 + Math.floor(Math.random()*40);
    for(let m=0; m<M; m++){
      const t = Math.random();
      const col = Math.floor(Math.random()*(columns-1));
      rawLines.push({ t, col });
    }
    // æŒ‰ t å‡åº
    rawLines.sort((a,b) => a.t - b.t);

    const minDist = 0.02;  // æœ€å°ç«–ç›´é—´éš”
    let finalHL = [];
    let prevT = -999, prevC = -999;
    for(let i=0; i<rawLines.length; i++){
      const { t, col } = rawLines[i];
      if (Math.abs(t - prevT) < minDist) {
        continue;
      }
      finalHL.push({ t, col });
      prevT = t;
      prevC = col;
    }

    // ç»˜åˆ¶åˆ° SVG
    finalHL.forEach(lineObj => {
      const { t, col } = lineObj;
      const p1 = snakeFuncs[col](t);
      const p2 = snakeFuncs[col+1](t);
      const pathData = createBridgeWavePath(p1.x, p1.y, p2.x, p2.y);
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg","path");
      pathElem.setAttribute("d", pathData);
      pathElem.setAttribute("class", "bridge-line");
      svg.appendChild(pathElem);
    });

    // ä¸‹è½æ—¶æŸ¥æ‰¾çš„æ¨ªæ¢æ•°æ®; è¿™é‡Œç•™ä¸€ä»½åŸå§‹æ•°æ®
    let linesData = finalHL.slice();

    /**************************************************************
     * 4. åŠ¨ç”»ï¼šç«–ç›´ä¸‹è½ & æ¨ªæ¢ç§»åŠ¨ (ç»Ÿä¸€åƒç´ é€Ÿåº¦)
     **************************************************************/
    const movingCircle = document.getElementById("movingCircle");
    let animationInProgress = false;
    let currentCol = 0;
    let currentT = 0;
    let state = "down";
    let nextLine = null; 
    let targetCol = 0;   

    // ç«–ç›´é€Ÿåº¦
    const paramStep = 0.005; 
    const verticalPxPerFrame = (bottomY - topY) * paramStep;

    let intervalId = null;

    function onTopCircleClick(e){
      if (animationInProgress) return;
      animationInProgress = true;

      currentCol = parseInt(e.target.dataset.colIndex);
      currentT = 0;
      state = "down";
      movingCircle.style.display = "block";

      let pt = snakeFuncs[currentCol](0);
      movingCircle.setAttribute("cx", pt.x);
      movingCircle.setAttribute("cy", pt.y);

      intervalId = setInterval(animationLoop, 20);
    }

    function animationLoop(){
      if (state === "down"){
        let candidate = getNextLine(currentCol, currentT);
        let boundaryT = 1;
        if (candidate) {
          boundaryT = candidate.t;
        }

        if (currentT + paramStep >= boundaryT){
          currentT = boundaryT;
          let p = snakeFuncs[currentCol](currentT);
          movingCircle.setAttribute("cx", p.x);
          movingCircle.setAttribute("cy", p.y);

          if (Math.abs(currentT - 1) < 1e-5){
            endAnimation();
            return;
          }
          nextLine = candidate;
          if (candidate.col === currentCol){
            targetCol = currentCol + 1;
          } else {
            targetCol = currentCol - 1;
          }
          state = "horizontal";
        } else {
          currentT += paramStep;
          let p = snakeFuncs[currentCol](currentT);
          movingCircle.setAttribute("cx", p.x);
          movingCircle.setAttribute("cy", p.y);
        }
      }
      else if (state === "horizontal"){
        let p1 = snakeFuncs[currentCol](currentT);
        let p2 = snakeFuncs[targetCol](currentT);
        let dist = distance(p1, p2);

        if (!nextLine._progress) {
          nextLine._progress = 0;
          // ====== åŸå…ˆè¿™é‡Œæœ‰åˆ é™¤ linesData çš„é€»è¾‘ï¼Œå»æ‰å³å¯ ======
          // let idx = linesData.indexOf(nextLine);
          // if (idx >= 0) linesData.splice(idx, 1);
        }

        let fractionPerFrame = dist > 0 ? (verticalPxPerFrame / dist) : 1;

        if (nextLine._progress < 1){
          nextLine._progress += fractionPerFrame;
          if (nextLine._progress > 1) nextLine._progress = 1;

          let currentX = p1.x + (p2.x - p1.x) * nextLine._progress;
          let currentY = p1.y + (p2.y - p1.y) * nextLine._progress;
          movingCircle.setAttribute("cx", currentX);
          movingCircle.setAttribute("cy", currentY);
        } else {
          currentCol = targetCol;
          currentT += 0.01;
          state = "down";
          nextLine = null;
        }
      }
    }

    // åŠ¨ç”»ç»“æŸï¼Œé‡ç½® linesDataï¼Œè®©ä¸‹ä¸€æ¬¡ç‚¹å‡»å¯ä»¥æ­£å¸¸ä½¿ç”¨æ‰€æœ‰æ¨ªæ¢
    function endAnimation(){
      clearInterval(intervalId);
      movingCircle.style.display = "none";
      animationInProgress = false;

      let { text, icon } = finalColumnBlessings[currentCol];
      showFinalPopup(text, icon);

      // =========== åœ¨æ­¤å¤„â€œå¤åŸå‚æ•°â€ï¼Œæ¢å¤ linesData =============
      linesData = finalHL.slice();   // å›åˆ°åˆå§‹å®Œæ•´çš„æ¨ªæ¢æ•°ç»„
      // å¦‚æœ _progress å·²æœ‰è®°å½•ï¼Œå¯ä»¥æ¸…æ‰(ä¸æ¸…ä¹Ÿæ²¡å•¥å½±å“)
      linesData.forEach(ln => { delete ln._progress; });
    }

    function getNextLine(col, t){
      let candidates = linesData.filter(ln =>
        (ln.col === col || ln.col === col - 1) && ln.t > t
      );
      if (candidates.length === 0) return null;
      return candidates.reduce((prev, curr) => (curr.t < prev.t ? curr : prev));
    }

    /**************************************************************
     * 5. åº•éƒ¨å›¾æ ‡
     **************************************************************/
    const bottomLabels = document.getElementById("bottomLabels");
    for(let i=0; i<columns; i++){
      const img = document.createElement("img");
      img.src = "cs.jpeg";
      bottomLabels.appendChild(img);
    }

    /**************************************************************
     * 6. å¼¹çª—ç¥ç¦
     **************************************************************/
    const finalPopup = document.getElementById("finalPopup");
    const finalIcon = document.getElementById("finalIcon");
    const finalBlessing = document.getElementById("finalBlessing");
    const closePopup = document.getElementById("closePopup");

    function showFinalPopup(text, icon){
      finalIcon.innerText = icon;
      finalBlessing.innerText = text;
      finalPopup.classList.add("show");
    }
    closePopup.addEventListener("click", ()=>{
      finalPopup.classList.remove("show");
    });

    /**************************************************************
     * å·¥å…·å‡½æ•°
     **************************************************************/
    function createSnakeFunction(cx, top, bottom){
      const H = bottom - top;
      const waveCount = 4 + Math.floor(Math.random()*3);
      const amplitude = 25 + Math.random()*15;
      return function(t){
        let y = top + t*H;
        let segLen = 1 / waveCount;
        let segIndex = Math.floor(t / segLen);
        if (segIndex >= waveCount) segIndex = waveCount - 1;
        let tInSeg = (t - segIndex*segLen) / segLen;
        let dir = (segIndex % 2 === 0) ? 1 : -1;

        let offset = amplitude * Math.sin(Math.PI * tInSeg);
        return { x: cx + dir*offset, y };
      };
    }

    function generatePathData(fn, t0, t1, steps){
      let dt = (t1 - t0)/steps;
      let { x, y } = fn(t0);
      let d = `M ${x},${y}`;
      for (let i=1; i<=steps; i++){
        let t = t0 + dt*i;
        let p = fn(t);
        d += ` L ${p.x},${p.y}`;
      }
      return d;
    }

    function createBridgeWavePath(x1, y1, x2, y2){
      let midX = (x1 + x2)/2;
      let midY = (y1 + y2)/2;
      let amp = 10;
      return `M ${x1},${y1}
              C ${midX},${midY - amp} ${midX},${midY + amp} ${x2},${y2}`;
    }

    function distance(a, b){
      let dx = a.x - b.x;
      let dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }
  </script>
</body>
</html>
