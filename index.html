<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>è›‡å¹´æŠ½ç­¾æ”¶ç¥ç¦-byé™ˆç¡•è€å¸ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* ============ é¡µé¢æ•´ä½“é£æ ¼ ============ */
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #ffeef4 30%, #ffdff0 100%);
      font-family: 'Comic Sans MS', 'å¹¼åœ†', cursive;
      overflow-x: hidden;
      overflow-y: auto;
      position: relative;
      min-height: 100vh;
    }

    /* é¡¶éƒ¨æ ‡é¢˜ */
    h1 {
      text-align: center;
      color: #ff6699;
      margin: 16px 0 0;
      font-size: 1.8rem;
      text-shadow: 1px 1px #fff;
      position: relative;
    }
    h1 img {
      width: 40px;
      vertical-align: middle;
      margin-right: 6px;
    }
    .subtitle {
      text-align: center;
      color: #777;
      font-size: 0.9rem;
      margin: 4px auto 12px;
    }

    /* ============ æ•´ä½“å®¹å™¨ ============ */
    .container {
      width: 100%;
      max-width: 420px;
      margin: 0 auto 30px;
      border: 2px solid #ff6699;
      border-radius: 12px;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 2px 8px rgba(255, 100, 150, 0.2);
      overflow: hidden;
      position: relative;
      padding: 10px 0 20px;
    }

    /* ============ SVGä¸»åŒºåŸŸ ============ */
    .amidakuji-area {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    svg {
      background: #ffeeef;
      border: 2px dashed #ff6699;
      border-radius: 8px;
      width: 100%;
      max-width: 400px;
      height: 600px;
      position: relative;
    }

    /* è›‡å½¢ç«–çº¿ã€æ³¢æµªæ¨ªçº¿çš„å¤–è§‚ */
    .snake-line {
      fill: none;
      stroke: #ff66aa;
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.9;
    }
    .bridge-line {
      fill: none;
      stroke: #ffaa44;
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.9;
    }

    /* é¡¶éƒ¨å¯ç‚¹å‡»åœ†ç‚¹ */
    .top-circle {
      fill: #ff88cc;
      stroke: #fff;
      stroke-width: 2;
      cursor: pointer;
      transition: fill 0.2s;
    }
    .top-circle:hover {
      fill: #ffb3d9; /* ä»…æ”¹å˜é¢œè‰²ï¼Œä¸ç¼©æ”¾ */
    }

    /* å°çƒ */
    #movingCircle {
      fill: #ff8844;
      stroke: #fff;
      stroke-width: 2;
      display: none;
      filter: drop-shadow(0 0 6px rgba(255,150,0,0.6));
    }

    /* ============ åº•éƒ¨é—®å·å›¾æ ‡ ============ */
    .bottom-labels {
      margin-top: 10px;
      display: flex;
      justify-content: space-around;
      align-items: center;
    }
    .bottom-labels img {
      width: 38px;
      height: 38px;
    }

    /* ============ å¤§å¼¹çª— - æ˜¾ç¤ºç¥ç¦ ============ */
    .final-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.7);
      background: rgba(255, 255, 255, 0.95);
      border: 3px solid #ff6699;
      border-radius: 10px;
      padding: 20px;
      width: 80%;
      max-width: 320px;
      text-align: center;
      box-shadow: 0 0 10px rgba(255, 100, 150, 0.3);
      transition: transform 0.4s ease, opacity 0.4s ease;
      z-index: 9999;
      opacity: 0;
    }
    .final-popup.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
    .final-icon {
      font-size: 2rem;
      margin-bottom: 8px;
    }
    .final-blessing {
      color: #ff6699;
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 10px;
      white-space: nowrap;
    }
    .close-btn {
      border: none;
      background: #ff6699;
      color: #fff;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 0 3px rgba(255,100,150,0.2);
    }
    .close-btn:hover {
      background: #ff3377;
    }
  </style>
</head>
<body>
  <h1>
    <img src="snake.png" alt="snake" />
    è›‡å¹´æŠ½ç¥ç¦-byé™ˆç¡•è€å¸ˆ
  </h1>
  <div class="subtitle">ç‚¹å‡»é¡¶éƒ¨åœ†ç‚¹ï¼Œæ²¿è›‡å½¢ç«–æ†ç©¿æ¢­ï¼Œçœ‹çœ‹èƒ½æŠ½åˆ°å•¥æƒŠå–œï¼Ÿ</div>

  <div class="container">
    <div class="amidakuji-area">
      <svg id="amidakujiSvg" viewBox="0 0 400 600" preserveAspectRatio="xMidYMid meet">
        <!-- ç”¨JSç”Ÿæˆ7æ¡è›‡å½¢æ›²çº¿ã€éšæœºæ¨ªæ¢ï¼Œä»¥åŠé¡¶éƒ¨åœ†ç‚¹ -->
        <circle id="movingCircle" r="8" cx="0" cy="0" />
      </svg>
    </div>
  </div>

  <!-- åº•éƒ¨ä½¿ç”¨é—®å·å›¾æ ‡ -->
  <div class="container" style="padding:5px 0 15px 0;">
    <div class="bottom-labels" id="bottomLabels"></div>
  </div>

  <!-- æœ€ç»ˆç¥ç¦å¼¹çª— -->
  <div class="final-popup" id="finalPopup">
    <div class="final-icon" id="finalIcon"></div>
    <div class="final-blessing" id="finalBlessing"></div>
    <button class="close-btn" id="closePopup">æ”¶åˆ°å•¦^_^</button>
  </div>

  <script>
    /**************************************************************
     * 1. æ•°æ®å‡†å¤‡ & å‚æ•°
     **************************************************************/
    const columns = 7;
    const width = 400, height = 600;
    const topY = 70, bottomY = 530; // åœ¨SVGé‡Œä¸Šä¸‹è¾¹ç•Œ

    // æ¯åˆ—éšæœºç»‘å®šçš„ç¥ç¦(å«å›¾æ ‡)
    const blessings = [
      { text: "æ•°å­¦å…¨æ»¡åˆ†", icon: "ğŸ“š" },
      { text: "è¶Šæ¥è¶Šèªæ˜", icon: "ğŸ“" },
      { text: "å¿«ä¹èƒ½é‡æ»¡æ»¡", icon: "ğŸˆ" },
      { text: "æ‰“è´¥éš¾é¢˜å¤§é­”ç‹", icon: "ğŸ‘¾" },
      { text: "èº«ä½“å£®å£®ä¸ç”Ÿç—…", icon: "ğŸ’ª" },
      { text: "å¤©å¤©ç¬‘å®¹ç¿çƒ‚", icon: "ğŸ˜Š" },
      { text: "çœ‹é€ä¸€åˆ‡çŸ¥è¯†çš„æœ¬è´¨", icon: "ğŸ”" },
      { text: "æ–°å¹´å¿«ä¹", icon: "ğŸ§¨" },
      { text: "å­¦ä¸šè¿›æ­¥", icon: "ğŸ“–" },
      { text: "å¥åº·æˆé•¿", icon: "ğŸŒ±" },
      { text: "å¿ƒæƒ³äº‹æˆ", icon: "ğŸŒŸ" },
      { text: "å˜èº«å¤©æ‰æ•°å­¦å®¶", icon: "ğŸ¨" },
    //   { text: "å‹‡æ•¢åšè‡ªå·±", icon: "ğŸ’–" },
    //   { text: "å‹æƒ…å¸¸åœ¨", icon: "ğŸ¤" },
    //   { text: "å¤©å¤©éƒ½æœ‰å¥½å¿ƒæƒ…", icon: "ğŸ˜†" },
    //   { text: "æˆä¸ºéŸ³ä¹å°è¾¾äºº", icon: "ğŸµ" },
      { text: "å¹¸è¿å¸¸ä¼´ä½ å·¦å³", icon: "ğŸŒˆ" },
      { text: "è®°å¿†è¶…ç¾¤ã€è¿‡ç›®ä¸å¿˜", icon: "âœ¨" },
    ];
    let temp = [...blessings];
    const finalColumnBlessings = [];
    for(let i=0; i<columns; i++){
      const idx = Math.floor(Math.random()*temp.length);
      finalColumnBlessings.push(temp[idx]);
      temp.splice(idx,1);
    }

    // åœ¨SVGä¸­ï¼Œè¦ä¸º7åˆ—ç”Ÿæˆâ€œè›‡å½¢å‡½æ•°â€
    const colSpacing = (width - 80)/(columns - 1);
    const colXs = [];
    for (let i=0; i<columns; i++){
      colXs.push(40 + i*colSpacing);
    }

    let snakeFuncs = [];
    let svg = document.getElementById("amidakujiSvg");

    /**************************************************************
     * 2. ç”Ÿæˆ 7 æ¡è›‡å½¢ç«–çº¿ + é¡¶éƒ¨åœ†ç‚¹
     **************************************************************/
    for (let i=0; i<columns; i++){
      const fn = createSnakeFunction(colXs[i], topY, bottomY);
      snakeFuncs.push(fn);

      // ç»˜åˆ¶ç«–çº¿(è›‡å½¢)
      const pathData = generatePathData(fn, 0, 1, 40 /*æ­¥æ•°*/);
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg","path");
      pathElem.setAttribute("d", pathData);
      pathElem.setAttribute("class", "snake-line");
      svg.appendChild(pathElem);

      // é¡¶éƒ¨å¯ç‚¹å‡»åœ†ç‚¹
      const ptTop = fn(0);
      const topCircle = document.createElementNS("http://www.w3.org/2000/svg","circle");
      topCircle.setAttribute("cx", ptTop.x);
      topCircle.setAttribute("cy", ptTop.y - 20);
      topCircle.setAttribute("r", 10);
      topCircle.setAttribute("class", "top-circle");
      topCircle.dataset.colIndex = i;
      topCircle.addEventListener("click", onTopCircleClick);
      svg.appendChild(topCircle);
    }

    /**************************************************************
     * 3. éšæœºç”Ÿæˆæ¨ªæ¢ + æœ€å°ç«–ç›´é—´éš”
     **************************************************************/
    let rawLines = [];
    // å…ˆéšæœºå‡ºè‹¥å¹²å€™é€‰(80~120)
    let M = 80 + Math.floor(Math.random()*40);
    for(let m=0; m<M; m++){
      const t = Math.random(); // 0..1
      const col = Math.floor(Math.random()*(columns-1));
      rawLines.push({ t, col });
    }
    // æŒ‰ t å‡åº
    rawLines.sort((a,b) => a.t - b.t);

    const minDist = 0.02;  // ç”Ÿæˆæ—¶æœ€å°ç«–ç›´é—´éš”: ä¸¤æ¡å¤ªè¿‘å°±è·³è¿‡
    let finalHL = [];
    let prevT = -999, prevC = -999;
    for(let i=0; i<rawLines.length; i++){
      const { t, col } = rawLines[i];
      // å¦‚æœå’Œä¸Šä¸€æ¡(å¯èƒ½åœ¨åŒcolæˆ–é‚»col)çš„tå€¼å·®å¤ªå°ï¼Œå°±è·³è¿‡
      if (Math.abs(t - prevT) < minDist) {
        continue;
      }
      finalHL.push({ t, col });
      prevT = t;
      prevC = col;
    }

    // ç»˜åˆ¶åˆ°SVG
    finalHL.forEach(lineObj => {
      const { t, col } = lineObj;
      const p1 = snakeFuncs[col](t);
      const p2 = snakeFuncs[col+1](t);
      const pathData = createBridgeWavePath(p1.x, p1.y, p2.x, p2.y);
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg","path");
      pathElem.setAttribute("d", pathData);
      pathElem.setAttribute("class", "bridge-line");
      svg.appendChild(pathElem);
    });

    // ä¾›ä¸‹è½æ—¶æŸ¥æ‰¾çš„æ¨ªæ¢æ•°æ®
    let linesData = finalHL.slice();

    /**************************************************************
     * 4. åŠ¨ç”»ï¼šç«–ç›´ä¸‹è½ & æ¨ªæ¢ç§»åŠ¨ï¼Œç»Ÿä¸€åƒç´ é€Ÿåº¦
     **************************************************************/
    const movingCircle = document.getElementById("movingCircle");
    let animationInProgress = false;
    let currentCol = 0;
    let currentT = 0;
    let state = "down";   // "down" or "horizontal"
    let nextLine = null;  // å½“å‰è¦ç”¨çš„æ¨ªæ¢
    let targetCol = 0;    // æ°´å¹³ç§»åŠ¨çš„ç›®æ ‡åˆ—

    // ç«–ç›´ä¸‹è½ï¼šä»¥ paramStep æ¥æ¨è¿› t
    // å¦‚æœ t ä» 0 åˆ° 1 æ¨ªè·¨ (bottomY - topY) åƒç´ ï¼Œåˆ™æ¯å¸§ç§»åŠ¨å¤šå°‘px?
    // paramStep=0.005 => æ¯å¸§ç›¸å½“äº (bottomY - topY) * 0.005 åƒç´ 
    const paramStep = 0.005; // æ¯å¸§ t çš„å¢é‡
    // å¤§çº¦ç«–ç›´åƒç´ é€Ÿåº¦(æ¯å¸§)
    const verticalPxPerFrame = (bottomY - topY) * paramStep;

    let intervalId = null;

    function onTopCircleClick(e){
      if (animationInProgress) return;
      animationInProgress = true;

      currentCol = parseInt(e.target.dataset.colIndex);
      currentT = 0;
      state = "down";
      movingCircle.style.display = "block";

      // è®¾ç½®èµ·å§‹ä½ç½®
      let pt = snakeFuncs[currentCol](0);
      movingCircle.setAttribute("cx", pt.x);
      movingCircle.setAttribute("cy", pt.y);

      intervalId = setInterval(animationLoop, 20);
    }

    function animationLoop(){
      if (state === "down"){
        // ç«–ç›´ä¸‹è½
        let candidate = getNextLine(currentCol, currentT);
        let boundaryT = 1; // åˆ°è¾¾åº•éƒ¨

        if (candidate) {
          boundaryT = candidate.t;
        }

        if (currentT + paramStep >= boundaryT){
          // åˆ°è¾¾æ­¤æ¨ªæ¢ or åˆ°åº•
          currentT = boundaryT;
          let p = snakeFuncs[currentCol](currentT);
          movingCircle.setAttribute("cx", p.x);
          movingCircle.setAttribute("cy", p.y);

          if (Math.abs(currentT - 1) < 1e-5){
            // åˆ°åº•
            endAnimation();
            return;
          }
          // é‡åˆ°æ¨ªæ¢ => è¿›å…¥æ°´å¹³æ–¹å‘
          nextLine = candidate;
          if (candidate.col === currentCol){
            targetCol = currentCol + 1;
          } else {
            targetCol = currentCol - 1;
          }
          state = "horizontal";
        } else {
          currentT += paramStep;
          let p = snakeFuncs[currentCol](currentT);
          movingCircle.setAttribute("cx", p.x);
          movingCircle.setAttribute("cy", p.y);
        }
      }
      else if (state === "horizontal"){
        // æ°´å¹³ç§»åŠ¨ï¼šåƒç´ é€Ÿåº¦ä¸ç«–ç›´ç›¸åŒ
        let p1 = snakeFuncs[currentCol](currentT);
        let p2 = snakeFuncs[targetCol](currentT);
        let dist = distance(p1, p2); // æ€»æ¨ªæ¢é•¿åº¦(åƒç´ )

        if (!nextLine._progress) {
          nextLine._progress = 0;
          // ç§»é™¤æ­¤æ¡æ¨ªæ¢ï¼Œé¿å…é‡å¤æ£€æµ‹
          let idx = linesData.indexOf(nextLine);
          if (idx >= 0) {
            linesData.splice(idx, 1);
          }
        }

        // æ¯å¸§åº”ç§»åŠ¨ verticalPxPerFrame åƒç´ ï¼Œ
        // å æ€»æ¡¥é•¿ dist çš„æ¯”ä¾‹ => fractionPerFrame
        let fractionPerFrame = dist > 0 ? (verticalPxPerFrame / dist) : 1;

        if (nextLine._progress < 1){
          nextLine._progress += fractionPerFrame;
          if (nextLine._progress > 1) nextLine._progress = 1;

          let currentX = p1.x + (p2.x - p1.x) * nextLine._progress;
          let currentY = p1.y + (p2.y - p1.y) * nextLine._progress;
          movingCircle.setAttribute("cx", currentX);
          movingCircle.setAttribute("cy", currentY);
        } else {
          // æ°´å¹³ç§»åŠ¨ç»“æŸ
          currentCol = targetCol;
          // è·³è¿‡ä¸€ç‚¹ï¼Œé˜²æ­¢ç«‹å³è¯†åˆ«åˆ°åŒä¸€ t (å‡ ä¹ä¸å˜)çš„å¹²æ‰°
          currentT += 0.01;
          state = "down";
          nextLine = null;
        }
      }
    }

    function endAnimation(){
      clearInterval(intervalId);
      movingCircle.style.display = "none";
      animationInProgress = false;

      // å¼¹çª—ç¥ç¦
      let { text, icon } = finalColumnBlessings[currentCol];
      showFinalPopup(text, icon);
    }

    // è·å–å½“å‰åˆ—ä¸‹æ–¹çš„ä¸‹ä¸€æ ¹æ¨ªæ¢
    function getNextLine(col, t){
      let candidates = linesData.filter(ln =>
        (ln.col === col || ln.col === col - 1) &&
        ln.t > t
      );
      if (candidates.length === 0) return null;
      // è¿”å› t æœ€å°çš„é‚£ä¸ª
      return candidates.reduce((prev, curr) => (curr.t < prev.t ? curr : prev));
    }

    /**************************************************************
     * 5. åº•éƒ¨é—®å·å›¾æ ‡
     **************************************************************/
    const bottomLabels = document.getElementById("bottomLabels");
    for(let i=0; i<columns; i++){
      const img = document.createElement("img");
      img.src = "cs.jpeg";
      bottomLabels.appendChild(img);
    }

    /**************************************************************
     * 6. å¼¹çª—æ˜¾ç¤ºç¥ç¦
     **************************************************************/
    const finalPopup = document.getElementById("finalPopup");
    const finalIcon = document.getElementById("finalIcon");
    const finalBlessing = document.getElementById("finalBlessing");
    const closePopup = document.getElementById("closePopup");

    function showFinalPopup(text, icon){
      finalIcon.innerText = icon;
      finalBlessing.innerText = text;
      finalPopup.classList.add("show");
    }
    closePopup.addEventListener("click", ()=>{
      finalPopup.classList.remove("show");
    });

    /**************************************************************
     * ========== å·¥å…·å‡½æ•°ï¼šè›‡å½¢ & æ¨ªæ¢ & è·ç¦» ==========
     **************************************************************/

    /**
     * createSnakeFunction(cx, top, bottom):
     *   è¿”å› f(t)(0..1) => {x, y},
     *   åœ¨ [top, bottom] çš„å‚ç›´èŒƒå›´å†…ç”»è‹¥å¹²æ³¢æµª.
     */
    function createSnakeFunction(cx, top, bottom){
      const H = bottom - top;
      const waveCount = 4 + Math.floor(Math.random()*3); // 4~6æ®µ
      const amplitude = 25 + Math.random()*15; // 25~40
      return function(t){
        let y = top + t*H;
        // æ¯æ®µé•¿åº¦
        let segLen = 1 / waveCount;
        let segIndex = Math.floor(t / segLen);
        if (segIndex >= waveCount) segIndex = waveCount - 1;
        let tInSeg = (t - segIndex*segLen) / segLen; // 0..1
        let dir = (segIndex % 2 === 0) ? 1 : -1;

        let offset = amplitude * Math.sin(Math.PI * tInSeg);
        return { x: cx + dir*offset, y };
      };
    }

    /**
     * generatePathData(fn, t0, t1, steps):
     *   å°† [tStart, tEnd] åŒºé—´ç­‰åˆ†, å– fn(t), æ‹¼æˆ path çš„ d å±æ€§
     */
    function generatePathData(fn, t0, t1, steps){
      let dt = (t1 - t0) / steps;
      let { x, y } = fn(t0);
      let d = `M ${x},${y}`;
      for (let i = 1; i <= steps; i++){
        let t = t0 + dt * i;
        let p = fn(t);
        d += ` L ${p.x},${p.y}`;
      }
      return d;
    }

    /**
     * createBridgeWavePath(x1, y1, x2, y2):
     *   åœ¨ (x1,y1) å’Œ (x2,y2) ä¹‹é—´ç”»ä¸€å°æ®µæ³¢æµª
     */
    function createBridgeWavePath(x1, y1, x2, y2){
      let midX = (x1 + x2) / 2;
      let midY = (y1 + y2) / 2;
      let amp = 10; // æ¨ªæ¢æ³¢æµªå¹…åº¦
      return `M ${x1},${y1}
              C ${midX},${midY - amp} ${midX},${midY + amp} ${x2},${y2}`;
    }

    /**
     * distance(p1, p2): è¿”å›ä¸¤ç‚¹ä¹‹é—´çš„åƒç´ è·ç¦»
     */
    function distance(a, b){
      let dx = a.x - b.x;
      let dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }
  </script>
</body>
</html>
